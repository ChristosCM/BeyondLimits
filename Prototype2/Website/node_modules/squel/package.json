{
  "_from": "squel",
  "_id": "squel@5.12.2",
  "_inBundle": false,
  "_integrity": "sha512-pIM8SjlUJlN2G6xz3we+lCp2aNQgxauGqKXJDi8y2n0hqJlSot0IUEdHh7/zGFFuRYnypbDiOhSWLZzT1BXnlQ==",
  "_location": "/squel",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "squel",
    "fetchSpec": "latest",
    "name": "squel",
    "raw": "squel",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/squel/-/squel-5.12.2.tgz",
  "_shasum": "8c7b54fd5462d95fe2432663c8762b65d29efe4c",
  "_spec": "squel",
  "_where": "/home/jake/Documents/BeyondLimits/Prototype2/Website",
  "author": {
    "email": "ram@hiddentao.com",
    "name": "Ramesh Nair",
    "url": "http://www.hiddentao.com/"
  },
  "bugs": {
    "url": "https://github.com/hiddentao/squel/issues"
  },
  "bundleDependencies": false,
  "contributors": [
    {
      "name": "Ramesh Nair",
      "email": "ram@hiddentao.com",
      "url": "http://www.hiddentao.com/"
    },
    {
      "name": "Sergej Brjuchanov",
      "email": "serges@seznam.cz"
    }
  ],
  "dependencies": {},
  "deprecated": false,
  "description": "SQL query string builder",
  "devDependencies": {
    "babel-preset-env": "^1.6.0",
    "benchmark": "^2.1.4",
    "chai": "1.5.x",
    "coffee-script": "^1.10.0",
    "growl": "^1.10.5",
    "gulp": "^3.9.1",
    "gulp-babel": "^6.1.2",
    "gulp-concat": "^2.6.0",
    "gulp-insert": "^0.5.0",
    "gulp-istanbul": "^1.1.1",
    "gulp-mocha": "^2.2.0",
    "gulp-replace": "^0.5.4",
    "gulp-uglify": "^1.5.3",
    "gulp-umd": "^0.2.0",
    "knex": "^0.14.6",
    "load-grunt-tasks": "~0.1.0",
    "mocha": "1.9.x",
    "run-sequence": "^1.1.5",
    "sinon": "1.6.x",
    "time-grunt": "~0.1.1",
    "uglify-js": "1.3.x",
    "underscore": "1.4.x",
    "yargs": "^4.7.1"
  },
  "engines": {
    "node": ">= 0.12.0"
  },
  "homepage": "https://github.com/hiddentao/squel#readme",
  "keywords": [
    "database",
    "rdbms",
    "sql"
  ],
  "main": "dist/squel.js",
  "name": "squel",
  "optionalDependencies": {},
  "readme": "# squel - SQL query string builder\n\n[![Build Status](https://secure.travis-ci.org/hiddentao/squel.svg?branch=master)](http://travis-ci.org/hiddentao/squel)\n[![CDNJS](https://img.shields.io/cdnjs/v/squel.svg)](https://cdnjs.com/libraries/squel)\n[![NPM module](https://badge.fury.io/js/squel.svg)](https://badge.fury.io/js/squel)\n[![NPM downloads](https://img.shields.io/npm/dm/squel.svg?maxAge=2592000)](https://www.npmjs.com/package/squel)\n[![Join the chat at https://discord.gg/PBAR2Bz](https://img.shields.io/badge/discord-join%20chat-738bd7.svg)](https://discord.gg/PBAR2Bz)\n[![Follow on Twitter](https://img.shields.io/twitter/url/http/shields.io.svg?style=social&label=Follow&maxAge=2592000)](https://twitter.com/hiddentao)\n\nA flexible and powerful SQL query string builder for Javascript.\n\nFull documentation (guide and API) at [https://hiddentao.com/squel/](https://hiddentao.com/squel/).\n\n## Features\n\n* Works in node.js and in the browser.\n* Supports the standard SQL queries: SELECT, UPDATE, INSERT and DELETE.\n* Supports non-standard commands for popular DB engines such as MySQL.\n* Supports paramterized queries for safe value escaping.\n* Can be customized to build any query or command of your choosing.\n* Uses method chaining for ease of use.\n* Small: ~7 KB minified and gzipped\n* And much more, [see the guide..](https://hiddentao.com/squel/)\n\n**WARNING: Do not ever pass queries generated on the client side to your web server for execution.** Such a configuration would make it trivial for a casual attacker to execute arbitrary queries&mdash;as with an SQL-injection vector, but much easier to exploit and practically impossible to protect against.\n\n_Note: Squel is suitable for production use, but you may wish to consider more\nactively developed alternatives such as [Knex](http://knexjs.org/)_\n\n## Installation\n\nInstall using [npm](http://npmjs.org/):\n\n```bash\n$ npm install squel\n```\n\n## Available files\n\n* `squel.js` - unminified version of Squel with the standard commands and all available non-standard commands added\n* `squel.min.js` - minified version of `squel.js`\n* `squel-basic.js` - unminified version of Squel with only the standard SQL commands\n* `squel-basic.min.js` - minified version of `squel-basic.js`\n\n\n## Examples\n\nBefore running the examples ensure you have `squel` installed and enabled at the top of your script:\n\n    var squel = require(\"squel\");\n\n### SELECT\n\n```javascript\n// SELECT * FROM table\nsquel.select()\n    .from(\"table\")\n    .toString()\n\n// SELECT t1.id, t2.name FROM table `t1` LEFT JOIN table2 `t2` ON (t1.id = t2.id) WHERE (t2.name <> 'Mark') AND (t2.name <> 'John') GROUP BY t1.id\nsquel.select()\n    .from(\"table\", \"t1\")\n    .field(\"t1.id\")\n    .field(\"t2.name\")\n    .left_join(\"table2\", \"t2\", \"t1.id = t2.id\")\n    .group(\"t1.id\")\n    .where(\"t2.name <> 'Mark'\")\n    .where(\"t2.name <> 'John'\")\n    .toString()\n\n// SELECT `t1`.`id`, `t1`.`name` as \"My name\", `t1`.`started` as \"Date\" FROM table `t1` WHERE age IN (RANGE(1, 1.2)) ORDER BY id ASC LIMIT 20\nsquel.select({ autoQuoteFieldNames: true })\n    .from(\"table\", \"t1\")\n    .field(\"t1.id\")\n    .field(\"t1.name\", \"My name\")\n    .field(\"t1.started\", \"Date\")\n    .where(\"age IN ?\", squel.str('RANGE(?, ?)', 1, 1.2))\n    .order(\"id\")\n    .limit(20)\n    .toString()\n```\n\nYou can build parameterized queries:\n\n```js\n/*\n{\n    text: \"SELECT `t1`.`id`, `t1`.`name` as \"My name\", `t1`.`started` as \"Date\" FROM table `t1` WHERE age IN (RANGE(?, ?)) ORDER BY id ASC LIMIT 20\",\n    values: [1, 1.2]\n}\n*/\nsquel.select({ autoQuoteFieldNames: true })\n    .from(\"table\", \"t1\")\n    .field(\"t1.id\")\n    .field(\"t1.name\", \"My name\")\n    .field(\"t1.started\", \"Date\")\n    .where(\"age IN ?\", squel.str('RANGE(?, ?)', 1, 1.2))\n    .order(\"id\")\n    .limit(20)\n    .toParam()\n```\n\n\nYou can use nested queries:\n\n```javascript\n// SELECT s.id FROM (SELECT * FROM students) `s` INNER JOIN (SELECT id FROM marks) `m` ON (m.id = s.id)\nsquel.select()\n    .from( squel.select().from('students'), 's' )\n    .field('id')\n    .join( squel.select().from('marks').field('id'), 'm', 'm.id = s.id' )\n    .toString()\n```\n\n### UPDATE\n\n```javascript\n// UPDATE test SET f1 = 1\nsquel.update()\n    .table(\"test\")\n    .set(\"f1\", 1)\n    .toString()\n\n// UPDATE test, test2, test3 AS `a` SET test.id = 1, test2.val = 1.2, a.name = \"Ram\", a.email = NULL, a.count = a.count + 1\nsquel.update()\n    .table(\"test\")\n    .set(\"test.id\", 1)\n    .table(\"test2\")\n    .set(\"test2.val\", 1.2)\n    .table(\"test3\",\"a\")\n    .setFields({\n        \"a.name\": \"Ram\",\n        \"a.email\": null,\n        \"a.count = a.count + 1\": undefined\n    })\n    .toString()\n```\n\n### INSERT\n\n```javascript\n// INSERT INTO test (f1) VALUES (1)\nsquel.insert()\n    .into(\"test\")\n    .set(\"f1\", 1)\n    .toString()\n\n// INSERT INTO test (name, age) VALUES ('Thomas', 29), ('Jane', 31)\nsquel.insert()\n    .into(\"test\")\n    .setFieldsRows([\n        { name: \"Thomas\", age: 29 },\n        { name: \"Jane\", age: 31 }    \n    ])\n    .toString()\n```\n\n### DELETE\n\n```javascript\n// DELETE FROM test\nsquel.delete()\n    .from(\"test\")\n    .toString()\n\n// DELETE FROM table1 WHERE (table1.id = 2) ORDER BY id DESC LIMIT 2\nsquel.delete()\n    .from(\"table1\")\n    .where(\"table1.id = ?\", 2)\n    .order(\"id\", false)\n    .limit(2)\n```\n\n### Paramterized queries\n\nUse the `useParam()` method to obtain a parameterized query with a separate list of formatted parameter values:\n\n```javascript\n// { text: \"INSERT INTO test (f1, f2, f3, f4, f5) VALUES (?, ?, ?, ?, ?)\", values: [1, 1.2, \"TRUE\", \"blah\", \"NULL\"] }\nsquel.insert()\n    .into(\"test\")\n    .set(\"f1\", 1)\n    .set(\"f2\", 1.2)\n    .set(\"f3\", true)\n    .set(\"f4\", \"blah\")\n    .set(\"f5\", null)\n    .toParam()\n```\n\n\n### Expression builder\n\nThere is also an expression builder which allows you to build complex expressions for `WHERE` and `ON` clauses:\n\n```javascript\n// test = 3 OR test = 4\nsquel.expr()\n    .or(\"test = 3\")\n    .or(\"test = 4\")\n    .toString()\n\n// test = 3 AND (inner = 1 OR inner = 2) OR (inner = 3 AND inner = 4 OR (inner IN ('str1, 'str2', NULL)))\nsquel.expr()\n    .and(\"test = 3\")\n    .and(\n        squel.expr()\n            .or(\"inner = 1\")\n            .or(\"inner = 2\")\n    )\n    .or(\n        squel.expr()\n            .and(\"inner = ?\", 3)\n            .and(\"inner = ?\", 4)\n            .or(\n                squel.expr()\n                    .and(\"inner IN ?\", ['str1', 'str2', null])\n            )\n    )\n    .toString()\n\n// SELECT * FROM test INNER JOIN test2 ON (test.id = test2.id) WHERE (test = 3 OR test = 4)\nsquel.select()\n    .join( \"test2\", null, squel.expr().and(\"test.id = test2.id\") )\n    .where( squel.expr().or(\"test = 3\").or(\"test = 4\") )\n```\n\n### Custom value types\n\nBy default Squel does not support the use of object instances as field values. Instead it lets you tell it how you want\nspecific object types to be handled:\n\n```javascript\n// handler for objects of type Date\nsquel.registerValueHandler(Date, function(date) {\n  return date.getFullYear() + '/' + (date.getMonth() + 1) + '/' + date.getDate();\n});\n\nsquel.update().\n  .table('students')\n  .set('start_date', new Date(2013, 5, 1))\n  .toString()\n\n// UPDATE students SET start_date = '2013/6/1'\n```\n\n\n_Note that custom value handlers can be overridden on a per-instance basis (see the [docs](https://hiddentao.com/squel/))_\n\n### Custom queries\n\nSquel allows you to override the built-in query builders with your own as well as create your own types of queries:\n\n```javascript\n// ------------------------------------------------------\n// Setup the PRAGMA query builder\n// ------------------------------------------------------\nvar util = require('util');   // to use util.inherits() from node.js\n\nvar CommandBlock = function() {};\nutil.inherits(CommandBlock, squel.cls.Block);\n\n// private method - will not get exposed within the query builder\nCommandBlock.prototype._command = function(_command) {\n  this._command = _command;\n}\n\n// public method - will get exposed within the query builder\nCommandBlock.prototype.compress = function() {\n  this._command('compress');\n};\n\nCommandBlock.prototype.buildStr = function() {\n  return this._command.toUpperCase();\n};\n\n\n// generic parameter block\nvar ParamBlock = function() {};\nutil.inherits(ParamBlock, squel.cls.Block);\n\nParamBlock.prototype.param = function(p) {\n  this._p = p;\n};\n\nParamBlock.prototype.buildStr = function() {\n  return this._p;\n};\n\n\n// pragma query builder\nvar PragmaQuery = function(options) {\n  squel.cls.QueryBuilder.call(this, options, [\n      new squel.cls.StringBlock(options, 'PRAGMA'),\n      new CommandBlock(),\n      new ParamBlock()\n  ]);\n};\nutil.inherits(PragmaQuery, squel.cls.QueryBuilder);\n\n\n// convenience method (we can override built-in squel methods this way too)\nsquel.pragma = function(options) {\n  return new PragmaQuery(options)\n};\n\n\n// ------------------------------------------------------\n// Build a PRAGMA query\n// ------------------------------------------------------\n\nsquel.pragma()\n  .compress()\n  .param('test')\n  .toString();\n\n// 'PRAGMA COMPRESS test'\n```\n\nExamples of custom queries in the wild:\n\n * https://github.com/bostrt/squel-top-start-at (blog post about it: http://blog.bostrt.net/extending-squel-js/)\n\n\n## Non-standard SQL\n\nSquel supports the standard SQL commands and reserved words. However a number of database engines provide their own\nnon-standard commands. To make things easy Squel allows for different 'flavours' of SQL to be loaded and used.\n\nAt the moment Squel provides `mysql`, `mssql` and `postgres` flavours which augment query builders with additional commands (e.g. `INSERT ... RETURNING`\nfor use with Postgres).\n\nTo use this in node.js:\n\n```javascript\nvar squel = require('squel').useFlavour('postgres');\n```\n\nFor the browser:\n\n```html\n<script type=\"text/javascript\" src=\"https://rawgithub.com/hiddentao/squel/master/squel.min.js\"></script>\n<script type=\"text/javascript\">\n  squel = squel.useFlavour('postgres');\n</script>\n```\n\n(Internally the flavour setup method simply utilizes the [custom query mechanism](http://hiddentao.github.io/squel/#custom_queries) to effect changes).\n\nRead the the [API docs](http://hiddentao.github.io/squel/api.html) to find out available commands. Flavours of SQL which get added to\nSquel in the future will be usable in the above manner.\n\n## Building it\n\nTo build the code and run the tests:\n\n    $ npm install\n    $ npm test <-- this will build the code and run the tests\n\n## Releasing it\n\nInstructions for creating a new release of squel are in `RELEASE.md`.\n\n\n## Contributing\n\nContributions are welcome! Please see `CONTRIBUTING.md`.\n\n## Older verions\n\n**Note: The latest Squel version only works on Node 0.12 or above. Please use Squel 4.4.1 for Node <0.12. The [old 4.x docs](http://hiddentao.github.io/squel/v4/index.html) are also still available.**\n\n\n## Ports to other languages\n\n* .NET - https://github.com/seymourpoler/PetProjects/tree/master/SQUEL\n* .NET - https://github.com/seymourpoler/Squel.net\n* Crystal - https://github.com/seymourpoler/Squel.crystal\n\n## License\n\nMIT - see LICENSE.md\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/hiddentao/squel.git"
  },
  "scripts": {
    "build": "gulp",
    "prepublish": "npm run build",
    "test": "gulp",
    "test-performance": "node performance/select.js"
  },
  "types": "dist/squel.d.ts",
  "version": "5.12.2"
}
